"use scrict";

// Переходы
// break за­став­ля­ет ин­тер­пре­та­тор пе­рей­ти в ко­нец цикла
// continue заставляет ин­тер­пре­та­тор про­пус­тить ос­тав­шую­ся часть те­ла цик­ла
// return пе­рей­ти из вы­зван­ной функ­ции
// throw - создает исключение (try/catch/finally)

// иден­ти­фи­ка­тор: ин­ст­рук­ция

let i = 1;
mainloop: while (true) {
    // Про­грамм­ный код опу­щен...
    if (i == 1) {
        i++;
        continue mainloop; // Пе­ре­ход к сле­дую­щей ите­ра­ции име­но­ван­но­го цик­ла
    } else {
        break;
    }
    // Про­грамм­ный код опу­щен...
}

(function () {
    let arr = [
        [1, 2, 3,],
        [1, 5, 3,],
        [1, 2, 3,],
    ];
    loop1: for (let i = 0; i < arr.length; i++) {
        loop2: for (let j = 0; j < arr.length; j++) {
            console.log(i, j);
            if (arr[i][j] == 5) {
                break loop1;
            }
        }
    }
})();


while (false) {
    ;;
    continue;
}

do {
    continue;
} while (false);

for (let i = 0; i < 5; i++) {
    continue;
}

for (let prop in {}) {
    continue;
}


for (i = 0; i < data.length; i++) {
    if (!data[i]) continue;         // Не об­ра­ба­ты­вать не­оп­ре­де­лен­ные дан­ные
    total += data[i];
}

// Инструкция return
// return вы­ра­же­ние;

function square(x) { return x * x; }  // Функ­ция с ин­ст­рук­ци­ей return
square(2)
let result = square(2)                           // Этот вы­зов вер­нет 4128

for (let i = 0; i < 10; i++) {
    ;
}
console.log(i);

function f() {
    ;
    ;
    ;
    return undefined;
    return;
}


// undefined если нет инструкции return

function display_object(o) {
    // Сра­зу же вер­нуть управ­ле­ние, ес­ли ар­гу­мент име­ет зна­че­ние null или undefined
    if (!o) return;
    if (o == '') return;
    // Здесь на­хо­дит­ся ос­тав­шая­ся часть функ­ции...
}

// return 
// 123;


// Ин­ст­рук­ция throw име­ет сле­дую­щий син­так­сис:
// throw вы­ра­же­ние;
function factorial(x) {
    x.foo.bar;
    // Ес­ли вход­ной ар­гу­мент не яв­ля­ет­ся до­пус­ти­мым зна­че­ни­ем, воз­бу­ж­да­ет­ся ис­клю­че­ние!
    if (x < 0) throw new Error("x не мо­жет быть от­ри­ца­тель­ным");
    // В про­тив­ном слу­чае зна­че­ние вы­чис­ля­ет­ся и воз­вра­ща­ет­ся нор­маль­ным об­ра­зом
    for (var f = 1; x > 1; f *= x, x--) /* пус­тое те­ло цик­ла */;
    return f;
}

try {
    function f() {
        try {
            throw new Error('Some error');
        } catch (e) {
            //
            ;
            throw new Error('Some error'); // -> Внешний обработчик ошибок
        } finally {
            throw new Error('Some error'); // -> Внешний обработчик ошибок
        }
        throw new Error('Some error');
    }
} catch (e) {
// Внешний обработчик ошибок
} finally {

}

// try/catch/finally
try {
    // Обыч­но этот код без сбо­ев ра­бо­та­ет от на­ча­ла до кон­ца.
    // Но в ка­кой-то мо­мент в нем мо­жет быть сге­не­ри­ро­ва­но ис­клю­че­ние
    // ли­бо не­по­сред­ст­вен­но с по­мо­щью ин­ст­рук­ции throw, ли­бо кос­вен­но -
    // вы­зо­вом ме­то­да, ге­не­ри­рую­ще­го ис­клю­че­ние.
}
catch (e) {
    // Ин­ст­рук­ции в этом бло­ке вы­пол­ня­ют­ся то­гда и толь­ко то­гда, ко­гда в бло­ке try
    // воз­ни­ка­ет ис­клю­че­ние. Эти ин­ст­рук­ции мо­гут ис­поль­зо­вать ло­каль­ную пе­ре­мен­ную e,
    // ссы­лаю­щую­ся на объ­ект Error или на дру­гое зна­че­ние, ука­зан­ное в ин­ст­рук­ции throw.
    // Этот блок мо­жет ли­бо не­ко­то­рым об­ра­зом об­ра­бо­тать ис­клю­че­ние, ли­бо
    // про­иг­но­ри­ро­вать его, де­лая что-то дру­гое, ли­бо за­но­во сге­не­ри­ро­вать
    // ис­клю­че­ние с по­мо­щью ин­ст­рук­ции throw.
}
finally {
    // Этот блок со­дер­жит ин­ст­рук­ции, ко­то­рые вы­пол­ня­ют­ся все­гда, не­за­ви­си­мо от то­го,
    // что про­изош­ло в бло­ке try. Они вы­пол­ня­ют­ся, ес­ли блок try за­вер­шил­ся:
    //     1) как обыч­но, дос­тиг­нув кон­ца бло­ка
    //     2) из-за ин­ст­рук­ции break, continue или return
    //     3) с ис­клю­че­ни­ем, об­ра­бо­тан­ным при­ве­ден­ным в бло­ке catch вы­ше
    //     4) с не­пе­ре­хва­чен­ным ис­клю­че­ни­ем, ко­то­рое про­дол­жа­ет свое
    //        рас­про­стра­не­ние на бо­лее вы­со­кие уров­ни
}

try {
    // За­про­сить чис­ло у поль­зо­ва­те­ля
    let n = Number(prompt("Вве­ди­те по­ло­жи­тель­ное чис­ло", ""));
    // Вы­чис­лить фак­то­ри­ал чис­ла, пред­по­ла­гая, что вход­ные дан­ные кор­рект­ны
    let f = factorial(n);
    // Вы­вес­ти ре­зуль­тат
    alert(n + "! = " + f);
}
catch (ex) {   // Ес­ли дан­ные не­кор­рект­ны, управ­ле­ние бу­дет пе­ре­да­но сю­да
    alert(ex); // Со­об­щить поль­зо­ва­те­лю об ошиб­ке
}
